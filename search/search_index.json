{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Connected StreamElement widgets This is a repository that constains the source code for various widgets that can be configured to affect each other. How to use a widget Create a new custom widget in your StreamElements overlay editor Copy the code for the four source files Paste each file into the corresponding tab in the code editor","title":"Home"},{"location":"#connected-streamelement-widgets","text":"This is a repository that constains the source code for various widgets that can be configured to affect each other.","title":"Connected StreamElement widgets"},{"location":"#how-to-use-a-widget","text":"Create a new custom widget in your StreamElements overlay editor Copy the code for the four source files Paste each file into the corresponding tab in the code editor","title":"How to use a widget"},{"location":"widgets/chaosContributionListener/","text":"Summary A widget that listens for subs, tips, or bits and then adds time to a timer or spins a wheel Source Code html 1 2 3 4 5 6 7 8 9 10 < link href = \"https://fonts.googleapis.com/css?family={{fontFamily}}:400,700\" rel = \"stylesheet\" > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js\" >< /script> < script defer src = \"https://reboot0.de/hosted/js/se-tools.min.js\" >< /script> < div id = \"infoPanel\" class = \"rules\" > < h1 > Sub - a - thon < /h1> < p id = \"SubsText\" >< /p> < p id = \"BitsText\" >< /p> < p id = \"TipsText\" >< /p> < p id = \"MaxText\" >< /p> < /div> css 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 p { font - family : {{ fontFamily }}; color : {{ fontColour }}; font - weight : bold ; margin : 0 px ; padding : 10 px ; } h1 { font - family : {{ fontFamily }}; color : {{ fontColour }}; font - weight : bold ; font - size : 2 em ; padding : 10 px ; } . rules { background - color : {{ bgColour }}; border : 5 px solid {{ borderColour }}; border - radius : 20 px ; } . rules p { font - size : 1.3 em ; } js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 let fields ; let isEditor = false ; const eventQueue = []; let lastEventTime = 0 ; function onWidgetLoad ( obj ) { fields = obj . detail . fieldData ; const { max_duration } = fields ; SE_API . getOverlayStatus (). then (( value ) => isEditor = value . isEditorMode ); //This section sets all the text. So then in the repeating function, I only need to show/hide, rather than re-setting the p values const subText = \"Subs add \" + fields . sub_time . toString () + \" minutes to the stream\" ; const bitText = \"Each \" + fields . bit_minimum . toString () + \" bits will add \" + fields . bit_time . toString () + \" minutes to the stream\" ; const tipText = \"Each \" + fields . tip_currency + fields . tip_minimum . toString () + \" donation will add \" + fields . tip_time . toString () + \" minutes to the stream\" ; let maxText = '' ; if ( max_duration > 0 ) { maxText = \"The stream will last a maximum of \" + max_duration . toString () + \" hours\" ; } DOM . setText ( \"#SubsText\" , subText ); DOM . setText ( \"#BitsText\" , bitText ); DOM . setText ( \"#TipsText\" , tipText ); DOM . setText ( \"#MaxText\" , maxText ); DOM . find ( \"#infoPanel\" ). hidden = true ; if ( fields . show_info ) { setInterval ( function () { //Here we will show the panel, delay then hide the panel. //$('#infoPanel').show().delay(info_duration).hide(); DOM . find ( '#infoPanel' ). hidden = false ; setTimeout ( function () { DOM . find ( '#infoPanel' ). hidden = true ; }, fields . info_duration * 1000 ) }, fields . info_interval * 60000 ); } } function onWidgetButton ( data ) { if ( data . field === 'reload' && isEditor ) { document . location . href = document . location . href ; } } function onKVStoreUpdate ( data ) { const value = data . value const isEventMsg = data . key === 'customWidget.timeAdded' ; const isEditorMatch = value . isEditor === isEditor const newEvent = value . curTime > lastEventTime ; if ( isEventMsg && isEditorMatch && newEvent ) { lastEventTime = value . curTime ; startNextQueuedEvent (); } } function onSubBomb ( data ) { const bulkAmount = data . amount ; if ( bulkAmount % 5 == 0 ) { addEventToQueue (() => sendEvent ( data . sender , 'subbed' , fields . sub_time * bulkAmount , bulkAmount , true )); } else if ( bulkAmount % 2 == 0 ) { addEventToQueue (() => sendEvent ( data . sender , 'subbed' , - 1 * fields . sub_time * bulkAmount , bulkAmount )); return ; } else { addEventToQueue (() => sendEvent ( data . sender , 'subbed' , fields . sub_time * bulkAmount , bulkAmount )); return ; } } function onSubscriber ( data ) { addEventToQueue (() => sendEvent ( data . sender , 'subbed' , fields . sub_time )); } function onResub ( data ) { addEventToQueue (() => sendEvent ( data . sender , 'subbed' , fields . sub_time )); } function onSubGift ( data ) { addEventToQueue (() => sendEvent ( data . sender , 'subbed' , fields . sub_time )); } function onCheer ( data ) { const amount = data . amount ; if ( amount >= fields . bit_minimum ) { if ( data . message . toLowerCase (). includes ( \"!spin\" )) { addEventToQueue (() => sendEvent ( data . sender , 'cheered' , Math . floor ( amount / fields . bit_minimum ) * fields . bit_time , amount , true )); } else { addEventToQueue (() => sendEvent ( data . sender , 'cheered' , Math . floor ( amount / fields . bit_minimum ) * fields . bit_time , amount )); } } } function onTip ( data ) { const amount = data . amount ; if ( amount >= fields . tip_minimum ) { if ( data . message . toLowerCase (). includes ( \"!spin\" )) { addEventToQueue (() => sendEvent ( data . sender , 'tipped' , Math . floor ( amount / fields . tip_minimum ) * fields . tip_time , amount , true )); } else { addEventToQueue (() => sendEvent ( data . sender , 'tipped' , Math . floor ( amount / fields . tip_minimum ) * fields . tip_time , amount )); } } } function sendEvent ( name , type , num , amount , spinWheel ) { const event = ( dest ) => { SE_API . store . set ( 'eventMessage' , { dest : dest , data : { name , type , num , amount }, curTime : Date . now (), isEditor , }); }; if ( spinWheel ) { event ( fields . wheelName ); } else { event ( fields . timerName ); } } function addEventToQueue ( event ) { if ( eventQueue . length == 0 ) { event (); } eventQueue . push ( event ); } function startNextQueuedEvent () { eventQueue . shift (); // clears the last running event if ( eventQueue . length > 0 ) { eventQueue [ 0 ](); } } json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 { \"wheelName\" : { \"type\" : \"text\" , \"label\" : \"Wheel Name\" }, \"timerName\" : { \"type\" : \"text\" , \"label\" : \"TimerName\" }, \"show_info\" : { \"group\" : \"Info Panel\" , \"type\" : \"checkbox\" , \"label\" : \"Show Info Panel\" }, \"info_interval\" : { \"group\" : \"Info Panel\" , \"type\" : \"number\" , \"label\" : \"Show every X Minutes\" , \"value\" : 5 }, \"info_duration\" : { \"group\" : \"Info Panel\" , \"type\" : \"number\" , \"label\" : \"How long to show rules for (s)\" , \"value\" : 30 }, \"sub_time\" : { \"group\" : \"Info Panel\" , \"type\" : \"number\" , \"label\" : \"Set Sub Increment (m)\" , \"value\" : 5 }, \"bit_minimum\" : { \"group\" : \"Info Panel\" , \"type\" : \"number\" , \"label\" : \"Set Minimum Bit Donation\" , \"value\" : 100 }, \"bit_time\" : { \"group\" : \"Info Panel\" , \"type\" : \"number\" , \"label\" : \"Set Bit Increment (m)\" , \"value\" : 1 }, \"tip_currency\" : { \"group\" : \"Info Panel\" , \"type\" : \"text\" , \"label\" : \"Set Currency\" , \"value\" : \"$\" }, \"tip_minimum\" : { \"group\" : \"Info Panel\" , \"type\" : \"number\" , \"label\" : \"Set Minimum Donation Amount\" , \"value\" : 5 }, \"tip_time\" : { \"group\" : \"Info Panel\" , \"type\" : \"number\" , \"label\" : \"Set Tip Increment (m)\" , \"value\" : 5 }, \"fontFamily\" : { \"group\" : \"Style\" , \"type\" : \"googleFont\" , \"label\" : \"Select a font:\" , \"value\" : \"Roboto\" }, \"fontColour\" : { \"group\" : \"Style\" , \"type\" : \"colorpicker\" , \"label\" : \"Select Text Colour\" , \"value\" : \"#0000FF\" }, \"bgColour\" : { \"group\" : \"Style\" , \"type\" : \"colorpicker\" , \"label\" : \"Select BG Colour\" , \"value\" : \"rgba(0, 0, 255, 0.31)\" }, \"borderColour\" : { \"group\" : \"Style\" , \"type\" : \"colorpicker\" , \"label\" : \"Select Border Colour\" , \"value\" : \"#0000FF\" } }","title":"Chaos Listener"},{"location":"widgets/chaosContributionListener/#summary","text":"A widget that listens for subs, tips, or bits and then adds time to a timer or spins a wheel","title":"Summary"},{"location":"widgets/chaosContributionListener/#source-code","text":"","title":"Source Code"},{"location":"widgets/chaosContributionListener/#html","text":"1 2 3 4 5 6 7 8 9 10 < link href = \"https://fonts.googleapis.com/css?family={{fontFamily}}:400,700\" rel = \"stylesheet\" > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js\" >< /script> < script defer src = \"https://reboot0.de/hosted/js/se-tools.min.js\" >< /script> < div id = \"infoPanel\" class = \"rules\" > < h1 > Sub - a - thon < /h1> < p id = \"SubsText\" >< /p> < p id = \"BitsText\" >< /p> < p id = \"TipsText\" >< /p> < p id = \"MaxText\" >< /p> < /div>","title":"html"},{"location":"widgets/chaosContributionListener/#css","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 p { font - family : {{ fontFamily }}; color : {{ fontColour }}; font - weight : bold ; margin : 0 px ; padding : 10 px ; } h1 { font - family : {{ fontFamily }}; color : {{ fontColour }}; font - weight : bold ; font - size : 2 em ; padding : 10 px ; } . rules { background - color : {{ bgColour }}; border : 5 px solid {{ borderColour }}; border - radius : 20 px ; } . rules p { font - size : 1.3 em ; }","title":"css"},{"location":"widgets/chaosContributionListener/#js","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 let fields ; let isEditor = false ; const eventQueue = []; let lastEventTime = 0 ; function onWidgetLoad ( obj ) { fields = obj . detail . fieldData ; const { max_duration } = fields ; SE_API . getOverlayStatus (). then (( value ) => isEditor = value . isEditorMode ); //This section sets all the text. So then in the repeating function, I only need to show/hide, rather than re-setting the p values const subText = \"Subs add \" + fields . sub_time . toString () + \" minutes to the stream\" ; const bitText = \"Each \" + fields . bit_minimum . toString () + \" bits will add \" + fields . bit_time . toString () + \" minutes to the stream\" ; const tipText = \"Each \" + fields . tip_currency + fields . tip_minimum . toString () + \" donation will add \" + fields . tip_time . toString () + \" minutes to the stream\" ; let maxText = '' ; if ( max_duration > 0 ) { maxText = \"The stream will last a maximum of \" + max_duration . toString () + \" hours\" ; } DOM . setText ( \"#SubsText\" , subText ); DOM . setText ( \"#BitsText\" , bitText ); DOM . setText ( \"#TipsText\" , tipText ); DOM . setText ( \"#MaxText\" , maxText ); DOM . find ( \"#infoPanel\" ). hidden = true ; if ( fields . show_info ) { setInterval ( function () { //Here we will show the panel, delay then hide the panel. //$('#infoPanel').show().delay(info_duration).hide(); DOM . find ( '#infoPanel' ). hidden = false ; setTimeout ( function () { DOM . find ( '#infoPanel' ). hidden = true ; }, fields . info_duration * 1000 ) }, fields . info_interval * 60000 ); } } function onWidgetButton ( data ) { if ( data . field === 'reload' && isEditor ) { document . location . href = document . location . href ; } } function onKVStoreUpdate ( data ) { const value = data . value const isEventMsg = data . key === 'customWidget.timeAdded' ; const isEditorMatch = value . isEditor === isEditor const newEvent = value . curTime > lastEventTime ; if ( isEventMsg && isEditorMatch && newEvent ) { lastEventTime = value . curTime ; startNextQueuedEvent (); } } function onSubBomb ( data ) { const bulkAmount = data . amount ; if ( bulkAmount % 5 == 0 ) { addEventToQueue (() => sendEvent ( data . sender , 'subbed' , fields . sub_time * bulkAmount , bulkAmount , true )); } else if ( bulkAmount % 2 == 0 ) { addEventToQueue (() => sendEvent ( data . sender , 'subbed' , - 1 * fields . sub_time * bulkAmount , bulkAmount )); return ; } else { addEventToQueue (() => sendEvent ( data . sender , 'subbed' , fields . sub_time * bulkAmount , bulkAmount )); return ; } } function onSubscriber ( data ) { addEventToQueue (() => sendEvent ( data . sender , 'subbed' , fields . sub_time )); } function onResub ( data ) { addEventToQueue (() => sendEvent ( data . sender , 'subbed' , fields . sub_time )); } function onSubGift ( data ) { addEventToQueue (() => sendEvent ( data . sender , 'subbed' , fields . sub_time )); } function onCheer ( data ) { const amount = data . amount ; if ( amount >= fields . bit_minimum ) { if ( data . message . toLowerCase (). includes ( \"!spin\" )) { addEventToQueue (() => sendEvent ( data . sender , 'cheered' , Math . floor ( amount / fields . bit_minimum ) * fields . bit_time , amount , true )); } else { addEventToQueue (() => sendEvent ( data . sender , 'cheered' , Math . floor ( amount / fields . bit_minimum ) * fields . bit_time , amount )); } } } function onTip ( data ) { const amount = data . amount ; if ( amount >= fields . tip_minimum ) { if ( data . message . toLowerCase (). includes ( \"!spin\" )) { addEventToQueue (() => sendEvent ( data . sender , 'tipped' , Math . floor ( amount / fields . tip_minimum ) * fields . tip_time , amount , true )); } else { addEventToQueue (() => sendEvent ( data . sender , 'tipped' , Math . floor ( amount / fields . tip_minimum ) * fields . tip_time , amount )); } } } function sendEvent ( name , type , num , amount , spinWheel ) { const event = ( dest ) => { SE_API . store . set ( 'eventMessage' , { dest : dest , data : { name , type , num , amount }, curTime : Date . now (), isEditor , }); }; if ( spinWheel ) { event ( fields . wheelName ); } else { event ( fields . timerName ); } } function addEventToQueue ( event ) { if ( eventQueue . length == 0 ) { event (); } eventQueue . push ( event ); } function startNextQueuedEvent () { eventQueue . shift (); // clears the last running event if ( eventQueue . length > 0 ) { eventQueue [ 0 ](); } }","title":"js"},{"location":"widgets/chaosContributionListener/#json","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 { \"wheelName\" : { \"type\" : \"text\" , \"label\" : \"Wheel Name\" }, \"timerName\" : { \"type\" : \"text\" , \"label\" : \"TimerName\" }, \"show_info\" : { \"group\" : \"Info Panel\" , \"type\" : \"checkbox\" , \"label\" : \"Show Info Panel\" }, \"info_interval\" : { \"group\" : \"Info Panel\" , \"type\" : \"number\" , \"label\" : \"Show every X Minutes\" , \"value\" : 5 }, \"info_duration\" : { \"group\" : \"Info Panel\" , \"type\" : \"number\" , \"label\" : \"How long to show rules for (s)\" , \"value\" : 30 }, \"sub_time\" : { \"group\" : \"Info Panel\" , \"type\" : \"number\" , \"label\" : \"Set Sub Increment (m)\" , \"value\" : 5 }, \"bit_minimum\" : { \"group\" : \"Info Panel\" , \"type\" : \"number\" , \"label\" : \"Set Minimum Bit Donation\" , \"value\" : 100 }, \"bit_time\" : { \"group\" : \"Info Panel\" , \"type\" : \"number\" , \"label\" : \"Set Bit Increment (m)\" , \"value\" : 1 }, \"tip_currency\" : { \"group\" : \"Info Panel\" , \"type\" : \"text\" , \"label\" : \"Set Currency\" , \"value\" : \"$\" }, \"tip_minimum\" : { \"group\" : \"Info Panel\" , \"type\" : \"number\" , \"label\" : \"Set Minimum Donation Amount\" , \"value\" : 5 }, \"tip_time\" : { \"group\" : \"Info Panel\" , \"type\" : \"number\" , \"label\" : \"Set Tip Increment (m)\" , \"value\" : 5 }, \"fontFamily\" : { \"group\" : \"Style\" , \"type\" : \"googleFont\" , \"label\" : \"Select a font:\" , \"value\" : \"Roboto\" }, \"fontColour\" : { \"group\" : \"Style\" , \"type\" : \"colorpicker\" , \"label\" : \"Select Text Colour\" , \"value\" : \"#0000FF\" }, \"bgColour\" : { \"group\" : \"Style\" , \"type\" : \"colorpicker\" , \"label\" : \"Select BG Colour\" , \"value\" : \"rgba(0, 0, 255, 0.31)\" }, \"borderColour\" : { \"group\" : \"Style\" , \"type\" : \"colorpicker\" , \"label\" : \"Select Border Colour\" , \"value\" : \"#0000FF\" } }","title":"json"},{"location":"widgets/spinner/","text":"Summary A Simple spinner that can trigger any of the connected stream Elements Source Code html 1 2 3 4 5 6 7 8 < link href = \"https://fonts.googleapis.com/css?family={{fontFamily}}:400,700\" rel = \"stylesheet\" > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/gsap/2.0.2/TweenMax.min.js\" >< /script> < script src = \"https://cdn.jsdelivr.net/npm/winwheel@1.0.1/dist/Winwheel.min.js\" >< /script> < script defer src = \"https://reboot0.de/hosted/js/se-tools.min.js\" >< /script> < div id = \"container\" > < canvas id = \"canvas\" width = \"{{wheelSize}}\" height = \"{{wheelSize}}\" > < /canvas> < /div> css 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # wheelContainer { background - image : url ({ background }); background - repeat : no - repeat ; /* Ensure that background does not repeat */ background - position : center ; /* Ensure image is centred */ background - size : contain ; width : {{ wheelSize }} px ; /* Width and height should at least be the same as the canvas */ height : {{ wheelSize }} px ; } /* #canvas{ top:80px; left:80px; position:relative; } */ js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 let fields ; let isEditor = false ; let wheel ; let segments ; let wheelSpinning = false let curData = { num : 1 , type : 'subbed' , name : 'test User' , amount : 1 } let lastEventTime = 0 ; function onWidgetLoad ( obj ) { fields = obj . detail . fieldData ; segments = JSON . parse ( fields . segmentConfig ); SE_API . getOverlayStatus (). then (( value ) => isEditor = value . isEditorMode ); let sumWeights = 0 ; const weights = segments . map ( segment => segment . weight ). filter ( s => s ); if ( segments && weights ) { sumWeights = weights . reduce (( sum , weight ) => sum + weight , 0 ); } const displaySegments = segments . map ( segment => ({ text : segment . label , fillStyle : segment . color ?? random_hex_color_code (), size : segment . weight ? 360 * segment . weight / sumWeights : undefined })) wheel = new Winwheel ({ drawMode : fields . displayImage ?? 'image' , outerRadius : fields . wheelSize / 2 , // Set outer radius so wheel fits inside the background. innerRadius : fields . innerRadius , // Make wheel hollow so segments don't go all way to center. textFontSize : fields . textSize , // Set default font size for the segments. textOrientation : 'vertical' , // Make text vertial so goes down from the outside of wheel. textAlignment : 'outer' , // Align text to outside of wheel. numSegments : segments . length , // Specify number of segments. segments : displaySegments , // Define segments including colour and text. pins : { number : fields . pins , }, animation : { // Specify the animation to use. type : 'spinToStop' , duration : fields . duration , // Duration in seconds. spins : fields . spins , // Default number of complete spins. callbackFinished : 'onWheelStop()' } }); let loadedImg = new Image (); loadedImg . src = fields . wheelImage ; loadedImg . onload = function () { wheel . wheelImage = loadedImg ; // Make wheelImage equal the loaded image object. wheel . draw (); // Also call draw function to render the wheel. }; } function onWidgetButton ( data ) { if ( data . field === 'spinButton' ) { wheel . rotationAngle = 0 ; // wheel.stopAnimation(false); // wheel.startAnimation(); // wheelSpinning = true; } else if ( data . field === 'reload' && isEditor ) { document . location . href = document . location . href ; } } function onKVStoreUpdate ( data ) { const value = data . value const isEventMsg = data . key === 'customWidget.eventMessage' ; const nameMatch = value . dest === fields . name ; const isEditorMatch = value . isEditor === isEditor const newEvent = value . curTime > lastEventTime ; if ( isEventMsg && nameMatch && isEditorMatch && newEvent && ! wheelSpinning ) { lastEventTime = value . curTime ; curData = value . data ; wheel . rotationAngle = 0 ; wheel . stopAnimation ( false ); wheel . startAnimation (); wheelSpinning = true ; } } function onWheelStop () { wheelSpinning = false ; const segment = segments [ wheel . getIndicatedSegmentNumber () - 1 ]; if ( segment . dest ) { SE_API . store . set ( 'eventMessage' , { dest : segment . dest , msg : segment . msg , data : { ... curData , num : curData . num * segment . multiplier }, curTime : Date . now (), isEditor , }); } } const random_hex_color_code = () => { let n = ( Math . random () * 0xfffff * 1000000 ). toString ( 16 ); return '#' + n . slice ( 0 , 6 ); }; json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 { \"spinButton\" : { \"type\" : \"button\" , \"label\" : \"Spin wheel\" , \"value\" : \"spin\" }, \"name\" : { \"type\" : \"text\" , \"label\" : \"Wheel Name\" , \"value\" : \"wheel1\" }, \"segmentConfig\" : { \"type\" : \"text\" , \"label\" : \"Segment Config\" , \"value\" : \"{\\\"config\\\": [{\\\"label\\\":\\\"5x\\\",\\\"color\\\":\\\"#ff0000\\\",\\\"weight\\\":5,\\\"multiplier\\\":5},{\\\"label\\\":\\\"-3x\\\",\\\"color\\\":\\\"#00ff00\\\",\\\"weight\\\":10,\\\"multiplier\\\":-3},{\\\"label\\\":\\\",-10x\\\",\\\"color\\\":\\\"#ffffff\\\",\\\"weight\\\":3,\\\"multiplier\\\":-10},{\\\"label\\\":\\\",3x\\\",\\\"color\\\":\\\"#123123\\\",\\\"weight\\\":10,\\\"multiplier\\\":3},{\\\"label\\\":\\\"-5x\\\",\\\"color\\\":\\\"#421221\\\",\\\"weight\\\":5,\\\"multiplier\\\":-5},{\\\"label\\\":\\\"10x\\\",\\\"weight\\\":3,\\\"multiplier\\\":10}]}\" }, \"displayImage\" : { \"type\" : \"checkbox\" , \"label\" : \"Display Image\" , \"value\" : false }, \"wheelImage\" : { \"type\" : \"image-input\" , \"label\" : \"Wheel image image(instead of text)\" , \"value\" : \"\" }, \"wheelSize\" : { \"type\" : \"number\" , \"label\" : \"Wheel size\" , \"value\" : 412 }, \"innerRadius\" : { \"type\" : \"number\" , \"label\" : \"Inner radius size\" , \"value\" : 70 }, \"pins\" : { \"type\" : \"number\" , \"label\" : \"Pins count\" , \"value\" : 30 }, \"background\" : { \"type\" : \"image-input\" , \"label\" : \"Background image\" , \"value\" : \"https://cdn.streamelements.com/uploads/04d60fdc-a64e-4a72-ace0-8bcee7c51713.png\" }, \"textSize\" : { \"type\" : \"number\" , \"label\" : \"Text Size\" , \"value\" : 20 }, \"spins\" : { \"type\" : \"number\" , \"label\" : \"Number of spins\" , \"value\" : 5 }, \"duration\" : { \"type\" : \"slider\" , \"label\" : \"Duration (s)\" , \"value\" : 3 , \"min\" : 0 , \"max\" : 10 , \"steps\" : 1 } } Segment config The segments config is a json object in the form: { \"label\": string, \"color\": string, \"weight\": number, \"multiplier\": number, \"dest\": string, // the name of the connected element to trigger with this segment \"msg\": string // any message to send to a non spinner connected element }","title":"Spinner"},{"location":"widgets/spinner/#summary","text":"A Simple spinner that can trigger any of the connected stream Elements","title":"Summary"},{"location":"widgets/spinner/#source-code","text":"","title":"Source Code"},{"location":"widgets/spinner/#html","text":"1 2 3 4 5 6 7 8 < link href = \"https://fonts.googleapis.com/css?family={{fontFamily}}:400,700\" rel = \"stylesheet\" > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/gsap/2.0.2/TweenMax.min.js\" >< /script> < script src = \"https://cdn.jsdelivr.net/npm/winwheel@1.0.1/dist/Winwheel.min.js\" >< /script> < script defer src = \"https://reboot0.de/hosted/js/se-tools.min.js\" >< /script> < div id = \"container\" > < canvas id = \"canvas\" width = \"{{wheelSize}}\" height = \"{{wheelSize}}\" > < /canvas> < /div>","title":"html"},{"location":"widgets/spinner/#css","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 # wheelContainer { background - image : url ({ background }); background - repeat : no - repeat ; /* Ensure that background does not repeat */ background - position : center ; /* Ensure image is centred */ background - size : contain ; width : {{ wheelSize }} px ; /* Width and height should at least be the same as the canvas */ height : {{ wheelSize }} px ; } /* #canvas{ top:80px; left:80px; position:relative; } */","title":"css"},{"location":"widgets/spinner/#js","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 let fields ; let isEditor = false ; let wheel ; let segments ; let wheelSpinning = false let curData = { num : 1 , type : 'subbed' , name : 'test User' , amount : 1 } let lastEventTime = 0 ; function onWidgetLoad ( obj ) { fields = obj . detail . fieldData ; segments = JSON . parse ( fields . segmentConfig ); SE_API . getOverlayStatus (). then (( value ) => isEditor = value . isEditorMode ); let sumWeights = 0 ; const weights = segments . map ( segment => segment . weight ). filter ( s => s ); if ( segments && weights ) { sumWeights = weights . reduce (( sum , weight ) => sum + weight , 0 ); } const displaySegments = segments . map ( segment => ({ text : segment . label , fillStyle : segment . color ?? random_hex_color_code (), size : segment . weight ? 360 * segment . weight / sumWeights : undefined })) wheel = new Winwheel ({ drawMode : fields . displayImage ?? 'image' , outerRadius : fields . wheelSize / 2 , // Set outer radius so wheel fits inside the background. innerRadius : fields . innerRadius , // Make wheel hollow so segments don't go all way to center. textFontSize : fields . textSize , // Set default font size for the segments. textOrientation : 'vertical' , // Make text vertial so goes down from the outside of wheel. textAlignment : 'outer' , // Align text to outside of wheel. numSegments : segments . length , // Specify number of segments. segments : displaySegments , // Define segments including colour and text. pins : { number : fields . pins , }, animation : { // Specify the animation to use. type : 'spinToStop' , duration : fields . duration , // Duration in seconds. spins : fields . spins , // Default number of complete spins. callbackFinished : 'onWheelStop()' } }); let loadedImg = new Image (); loadedImg . src = fields . wheelImage ; loadedImg . onload = function () { wheel . wheelImage = loadedImg ; // Make wheelImage equal the loaded image object. wheel . draw (); // Also call draw function to render the wheel. }; } function onWidgetButton ( data ) { if ( data . field === 'spinButton' ) { wheel . rotationAngle = 0 ; // wheel.stopAnimation(false); // wheel.startAnimation(); // wheelSpinning = true; } else if ( data . field === 'reload' && isEditor ) { document . location . href = document . location . href ; } } function onKVStoreUpdate ( data ) { const value = data . value const isEventMsg = data . key === 'customWidget.eventMessage' ; const nameMatch = value . dest === fields . name ; const isEditorMatch = value . isEditor === isEditor const newEvent = value . curTime > lastEventTime ; if ( isEventMsg && nameMatch && isEditorMatch && newEvent && ! wheelSpinning ) { lastEventTime = value . curTime ; curData = value . data ; wheel . rotationAngle = 0 ; wheel . stopAnimation ( false ); wheel . startAnimation (); wheelSpinning = true ; } } function onWheelStop () { wheelSpinning = false ; const segment = segments [ wheel . getIndicatedSegmentNumber () - 1 ]; if ( segment . dest ) { SE_API . store . set ( 'eventMessage' , { dest : segment . dest , msg : segment . msg , data : { ... curData , num : curData . num * segment . multiplier }, curTime : Date . now (), isEditor , }); } } const random_hex_color_code = () => { let n = ( Math . random () * 0xfffff * 1000000 ). toString ( 16 ); return '#' + n . slice ( 0 , 6 ); };","title":"js"},{"location":"widgets/spinner/#json","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 { \"spinButton\" : { \"type\" : \"button\" , \"label\" : \"Spin wheel\" , \"value\" : \"spin\" }, \"name\" : { \"type\" : \"text\" , \"label\" : \"Wheel Name\" , \"value\" : \"wheel1\" }, \"segmentConfig\" : { \"type\" : \"text\" , \"label\" : \"Segment Config\" , \"value\" : \"{\\\"config\\\": [{\\\"label\\\":\\\"5x\\\",\\\"color\\\":\\\"#ff0000\\\",\\\"weight\\\":5,\\\"multiplier\\\":5},{\\\"label\\\":\\\"-3x\\\",\\\"color\\\":\\\"#00ff00\\\",\\\"weight\\\":10,\\\"multiplier\\\":-3},{\\\"label\\\":\\\",-10x\\\",\\\"color\\\":\\\"#ffffff\\\",\\\"weight\\\":3,\\\"multiplier\\\":-10},{\\\"label\\\":\\\",3x\\\",\\\"color\\\":\\\"#123123\\\",\\\"weight\\\":10,\\\"multiplier\\\":3},{\\\"label\\\":\\\"-5x\\\",\\\"color\\\":\\\"#421221\\\",\\\"weight\\\":5,\\\"multiplier\\\":-5},{\\\"label\\\":\\\"10x\\\",\\\"weight\\\":3,\\\"multiplier\\\":10}]}\" }, \"displayImage\" : { \"type\" : \"checkbox\" , \"label\" : \"Display Image\" , \"value\" : false }, \"wheelImage\" : { \"type\" : \"image-input\" , \"label\" : \"Wheel image image(instead of text)\" , \"value\" : \"\" }, \"wheelSize\" : { \"type\" : \"number\" , \"label\" : \"Wheel size\" , \"value\" : 412 }, \"innerRadius\" : { \"type\" : \"number\" , \"label\" : \"Inner radius size\" , \"value\" : 70 }, \"pins\" : { \"type\" : \"number\" , \"label\" : \"Pins count\" , \"value\" : 30 }, \"background\" : { \"type\" : \"image-input\" , \"label\" : \"Background image\" , \"value\" : \"https://cdn.streamelements.com/uploads/04d60fdc-a64e-4a72-ace0-8bcee7c51713.png\" }, \"textSize\" : { \"type\" : \"number\" , \"label\" : \"Text Size\" , \"value\" : 20 }, \"spins\" : { \"type\" : \"number\" , \"label\" : \"Number of spins\" , \"value\" : 5 }, \"duration\" : { \"type\" : \"slider\" , \"label\" : \"Duration (s)\" , \"value\" : 3 , \"min\" : 0 , \"max\" : 10 , \"steps\" : 1 } }","title":"json"},{"location":"widgets/spinner/#segment-config","text":"The segments config is a json object in the form: { \"label\": string, \"color\": string, \"weight\": number, \"multiplier\": number, \"dest\": string, // the name of the connected element to trigger with this segment \"msg\": string // any message to send to a non spinner connected element }","title":"Segment config"},{"location":"widgets/timer/","text":"Summary A simple timer that can be connected to a spinner Source Code html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 < link href = \"https://fonts.googleapis.com/css?family={{fontFamily}}:400,700\" rel = \"stylesheet\" > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js\" >< /script> < script defer src = \"https://reboot0.de/hosted/js/se-tools.min.js\" >< /script> < div id = \"overlay\" > < table class = \"container\" > < tr > < td > < div class = \"countdownContainer\" > < p id = \"countdown\" >< /p> < /div> < /td> < /tr> < tr > < td > < div class = \"eventContainer\" > < p id = \"event\" >< /p> < /div> < /td> < /tr> < /table> < /div> css 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 p { font - family : {{ fontFamily }}; color : {{ fontColour }}; font - weight : bold ; margin : 0 px ; padding : 10 px ; } h1 { font - family : {{ fontFamily }}; color : {{ fontColour }}; font - weight : bold ; font - size : 2 em ; padding : 10 px ; } . container { float : right ; } . countdownContainer { background - color : {{ bgColour }}; border : 5 px solid {{ borderColour }}; display : block ; border - radius : 20 px ; float : right ; } . countdownContainer p { font - size : 75 px ; } . eventContainer p { font - size : 25 px ; font - family : {{ fontFamily }}; color : {{ fontColour }}; } . eventContainer { background - color : {{ bgColour }}; border - radius : 20 px ; height : 0 px ; float : right ; border : 2 px solid {{ borderColour }}; } js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 let fields ; let isEditor = false ; let countDownTimer = Date . now (); let maxEndDate = Date . now (); let lastEventTime = 0 ; function onWidgetLoad ( obj ) { fields = obj . detail . fieldData ; SE_API . getOverlayStatus (). then (( value ) => isEditor = value . isEditorMode ); resetTimer (); SE_API . store . get ( 'curTime' ). then ( obj => { if ( obj . value ) { countDownTimer = obj . value } }); var x = setInterval ( function () { var now = new Date (). getTime (); var diff = countDownTimer - now ; var days = Math . floor ( diff / ( 1000 * 60 * 60 * 24 )); var hours = Math . floor (( diff % ( 1000 * 60 * 60 * 24 )) / ( 1000 * 60 * 60 )); var minutes = Math . floor (( diff % ( 1000 * 60 * 60 )) / ( 1000 * 60 )); var seconds = Math . floor (( diff % ( 1000 * 60 )) / 1000 ); document . getElementById ( 'countdown' ). innerHTML = days + \"d \" + hours + \"h \" + minutes + \"m \" + seconds + \"s\" ; }, 1000 ); DOM . find ( '#event' ). hidden = true ; DOM . find ( '.eventContainer' ). hidden = true ; } function onWidgetButton ( data ) { if ( data . field === 'reset_time' ) { resetTimer (); } else if ( data . field === 'store_time' ) { SE_API . store . set ( 'curTime' , countDownTimer ); } else if ( data . field === 'reload' && isEditor ) { document . location . href = document . location . href ; } } function onKVStoreUpdate ( data ) { const value = data . value const isEventMsg = data . key === 'customWidget.eventMessage' ; const nameMatch = value . dest === fields . name ; const isEditorMatch = value . isEditor === isEditor const newEvent = value . curTime > lastEventTime ; if ( isEventMsg && nameMatch && isEditorMatch && newEvent ) { lastEventTime = value . curTime ; addTimeToCounter ( value . data . num , value . data , value . data . type ); } } function addTimeToCounter ( minToAdd , event , type ) { countDownTimer = countDownTimer + ( minToAdd * 60000 ); if ( ! isEditor ) { SE_API . store . set ( 'curTime' , countDownTimer ); } var eventMsg = event [ \"name\" ] + \" \" + type ; var amountString = \"\" ; var minuteString = minToAdd . toString (); if ( type == \"subbed\" ) { if ( minuteString < 0 ) { minuteString = minuteString . split ( \"-\" )[ 1 ] eventMsg = ` ${ eventMsg } removing ${ minuteString } minutes from the timer` ; } else { eventMsg = ` ${ eventMsg } adding ${ minuteString } minutes to the timer` ; } } else if ( type == \"cheered\" ) { amountString = event [ \"amount\" ]. toString (); if ( minuteString < 0 ) { minuteString = minuteString . split ( \"-\" )[ 1 ] eventMsg = ` ${ eventMsg } ${ amountString } removing ${ minuteString } minutes from the timer` ; } else { eventMsg = ` ${ eventMsg } ${ amountString } adding ${ minuteString } minutes to the timer` ; } } else { amountString = event [ \"amount\" ]. toString (); if ( minuteString < 0 ) { minuteString = minuteString . split ( \"-\" )[ 1 ] eventMsg = ` ${ eventMsg } ${ tip_currency + amountString } removing ${ minuteString } minutes from the timer` ; } else { eventMsg = ` ${ eventMsg } ${ tip_currency + amountString } adding ${ minuteString } minutes to the timer` ; } } document . getElementById ( 'event' ). innerHTML = eventMsg ; $ ( '.eventContainer' ). show (). animate ({ height : \"50px\" }); $ ( '#event' ). show (); setTimeout ( function () { clearEvent (); }, 3000 ); } function clearEvent () { $ ( '.eventContainer' ). animate ({ height : \"0px\" }). hide (); $ ( '#event' ). hide (); SE_API . store . set ( 'timeAdded' , { curTime : Date . now (), isEditor , }); } function resetTimer () { countDownTimer = Date . now () + ( fields . initial_duration * 1000 * 60 * 60 ); } json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 { \"name\" : { \"type\" : \"text\" , \"label\" : \"Timer Name\" , \"value\" : \"timer1\" }, \"reset_time\" : { \"group\" : \"TimeConfig\" , \"type\" : \"button\" , \"label\" : \"Reset Timer\" , \"value\" : \"reset\" }, \"store_time\" : { \"group\" : \"TimeConfig\" , \"type\" : \"button\" , \"label\" : \"Store Time\" , \"value\" : \"store\" }, \"initial_duration\" : { \"group\" : \"TimeConfig\" , \"type\" : \"number\" , \"label\" : \"Initial Stream Length (h)\" , \"value\" : 5 }, \"max_duration\" : { \"group\" : \"TimeConfig\" , \"type\" : \"number\" , \"label\" : \"Max Stream Length (h)\" , \"value\" : 0 }, \"fontFamily\" : { \"group\" : \"Style\" , \"type\" : \"googleFont\" , \"label\" : \"Select a font:\" , \"value\" : \"Roboto\" }, \"fontColour\" : { \"group\" : \"Style\" , \"type\" : \"colorpicker\" , \"label\" : \"Select Text Colour\" , \"value\" : \"#0000FF\" }, \"bgColour\" : { \"group\" : \"Style\" , \"type\" : \"colorpicker\" , \"label\" : \"Select BG Colour\" , \"value\" : \"rgba(0, 0, 255, 0.31)\" }, \"borderColour\" : { \"group\" : \"Style\" , \"type\" : \"colorpicker\" , \"label\" : \"Select Border Colour\" , \"value\" : \"#0000FF\" } }","title":"Timer"},{"location":"widgets/timer/#summary","text":"A simple timer that can be connected to a spinner","title":"Summary"},{"location":"widgets/timer/#source-code","text":"","title":"Source Code"},{"location":"widgets/timer/#html","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 < link href = \"https://fonts.googleapis.com/css?family={{fontFamily}}:400,700\" rel = \"stylesheet\" > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js\" >< /script> < script defer src = \"https://reboot0.de/hosted/js/se-tools.min.js\" >< /script> < div id = \"overlay\" > < table class = \"container\" > < tr > < td > < div class = \"countdownContainer\" > < p id = \"countdown\" >< /p> < /div> < /td> < /tr> < tr > < td > < div class = \"eventContainer\" > < p id = \"event\" >< /p> < /div> < /td> < /tr> < /table> < /div>","title":"html"},{"location":"widgets/timer/#css","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 p { font - family : {{ fontFamily }}; color : {{ fontColour }}; font - weight : bold ; margin : 0 px ; padding : 10 px ; } h1 { font - family : {{ fontFamily }}; color : {{ fontColour }}; font - weight : bold ; font - size : 2 em ; padding : 10 px ; } . container { float : right ; } . countdownContainer { background - color : {{ bgColour }}; border : 5 px solid {{ borderColour }}; display : block ; border - radius : 20 px ; float : right ; } . countdownContainer p { font - size : 75 px ; } . eventContainer p { font - size : 25 px ; font - family : {{ fontFamily }}; color : {{ fontColour }}; } . eventContainer { background - color : {{ bgColour }}; border - radius : 20 px ; height : 0 px ; float : right ; border : 2 px solid {{ borderColour }}; }","title":"css"},{"location":"widgets/timer/#js","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 let fields ; let isEditor = false ; let countDownTimer = Date . now (); let maxEndDate = Date . now (); let lastEventTime = 0 ; function onWidgetLoad ( obj ) { fields = obj . detail . fieldData ; SE_API . getOverlayStatus (). then (( value ) => isEditor = value . isEditorMode ); resetTimer (); SE_API . store . get ( 'curTime' ). then ( obj => { if ( obj . value ) { countDownTimer = obj . value } }); var x = setInterval ( function () { var now = new Date (). getTime (); var diff = countDownTimer - now ; var days = Math . floor ( diff / ( 1000 * 60 * 60 * 24 )); var hours = Math . floor (( diff % ( 1000 * 60 * 60 * 24 )) / ( 1000 * 60 * 60 )); var minutes = Math . floor (( diff % ( 1000 * 60 * 60 )) / ( 1000 * 60 )); var seconds = Math . floor (( diff % ( 1000 * 60 )) / 1000 ); document . getElementById ( 'countdown' ). innerHTML = days + \"d \" + hours + \"h \" + minutes + \"m \" + seconds + \"s\" ; }, 1000 ); DOM . find ( '#event' ). hidden = true ; DOM . find ( '.eventContainer' ). hidden = true ; } function onWidgetButton ( data ) { if ( data . field === 'reset_time' ) { resetTimer (); } else if ( data . field === 'store_time' ) { SE_API . store . set ( 'curTime' , countDownTimer ); } else if ( data . field === 'reload' && isEditor ) { document . location . href = document . location . href ; } } function onKVStoreUpdate ( data ) { const value = data . value const isEventMsg = data . key === 'customWidget.eventMessage' ; const nameMatch = value . dest === fields . name ; const isEditorMatch = value . isEditor === isEditor const newEvent = value . curTime > lastEventTime ; if ( isEventMsg && nameMatch && isEditorMatch && newEvent ) { lastEventTime = value . curTime ; addTimeToCounter ( value . data . num , value . data , value . data . type ); } } function addTimeToCounter ( minToAdd , event , type ) { countDownTimer = countDownTimer + ( minToAdd * 60000 ); if ( ! isEditor ) { SE_API . store . set ( 'curTime' , countDownTimer ); } var eventMsg = event [ \"name\" ] + \" \" + type ; var amountString = \"\" ; var minuteString = minToAdd . toString (); if ( type == \"subbed\" ) { if ( minuteString < 0 ) { minuteString = minuteString . split ( \"-\" )[ 1 ] eventMsg = ` ${ eventMsg } removing ${ minuteString } minutes from the timer` ; } else { eventMsg = ` ${ eventMsg } adding ${ minuteString } minutes to the timer` ; } } else if ( type == \"cheered\" ) { amountString = event [ \"amount\" ]. toString (); if ( minuteString < 0 ) { minuteString = minuteString . split ( \"-\" )[ 1 ] eventMsg = ` ${ eventMsg } ${ amountString } removing ${ minuteString } minutes from the timer` ; } else { eventMsg = ` ${ eventMsg } ${ amountString } adding ${ minuteString } minutes to the timer` ; } } else { amountString = event [ \"amount\" ]. toString (); if ( minuteString < 0 ) { minuteString = minuteString . split ( \"-\" )[ 1 ] eventMsg = ` ${ eventMsg } ${ tip_currency + amountString } removing ${ minuteString } minutes from the timer` ; } else { eventMsg = ` ${ eventMsg } ${ tip_currency + amountString } adding ${ minuteString } minutes to the timer` ; } } document . getElementById ( 'event' ). innerHTML = eventMsg ; $ ( '.eventContainer' ). show (). animate ({ height : \"50px\" }); $ ( '#event' ). show (); setTimeout ( function () { clearEvent (); }, 3000 ); } function clearEvent () { $ ( '.eventContainer' ). animate ({ height : \"0px\" }). hide (); $ ( '#event' ). hide (); SE_API . store . set ( 'timeAdded' , { curTime : Date . now (), isEditor , }); } function resetTimer () { countDownTimer = Date . now () + ( fields . initial_duration * 1000 * 60 * 60 ); }","title":"js"},{"location":"widgets/timer/#json","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 { \"name\" : { \"type\" : \"text\" , \"label\" : \"Timer Name\" , \"value\" : \"timer1\" }, \"reset_time\" : { \"group\" : \"TimeConfig\" , \"type\" : \"button\" , \"label\" : \"Reset Timer\" , \"value\" : \"reset\" }, \"store_time\" : { \"group\" : \"TimeConfig\" , \"type\" : \"button\" , \"label\" : \"Store Time\" , \"value\" : \"store\" }, \"initial_duration\" : { \"group\" : \"TimeConfig\" , \"type\" : \"number\" , \"label\" : \"Initial Stream Length (h)\" , \"value\" : 5 }, \"max_duration\" : { \"group\" : \"TimeConfig\" , \"type\" : \"number\" , \"label\" : \"Max Stream Length (h)\" , \"value\" : 0 }, \"fontFamily\" : { \"group\" : \"Style\" , \"type\" : \"googleFont\" , \"label\" : \"Select a font:\" , \"value\" : \"Roboto\" }, \"fontColour\" : { \"group\" : \"Style\" , \"type\" : \"colorpicker\" , \"label\" : \"Select Text Colour\" , \"value\" : \"#0000FF\" }, \"bgColour\" : { \"group\" : \"Style\" , \"type\" : \"colorpicker\" , \"label\" : \"Select BG Colour\" , \"value\" : \"rgba(0, 0, 255, 0.31)\" }, \"borderColour\" : { \"group\" : \"Style\" , \"type\" : \"colorpicker\" , \"label\" : \"Select Border Colour\" , \"value\" : \"#0000FF\" } }","title":"json"}]}